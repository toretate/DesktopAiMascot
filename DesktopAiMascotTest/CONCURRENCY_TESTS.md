# 並行処理とマスコット音声分離テスト（ラジオモード対応）

## 概要

このドキュメントは、`StyleBertVits2ServiceConcurrencyTests.cs` に含まれる並行処理テストの目的と内容を説明します。
これらのテストは、今後実装予定のラジオモード（複数のマスコットが会話する機能）において、
TTS（Text-to-Speech）処理が前後してもマスコット毎の音声が混ざらないことを保証するために作成されました。

## テストケース一覧

### 1. 複数の話者が同時に音声合成をリクエストした場合_それぞれの音声データが混ざらない

**目的:** 2つの異なる話者IDで同時に音声合成をリクエストした場合、それぞれの音声データが正しく分離されることを確認します。

**シナリオ:**
- 話者1（speaker_id=1）と話者2（speaker_id=2）が同時に音声合成をリクエスト
- 各リクエストは50msの処理時間をシミュレート
- 返される音声データは話者ごとに異なる識別子を含む

**検証内容:**
- 話者1の音声データが正しく返されること
- 話者2の音声データが正しく返されること
- 2つの音声データが混ざっていないこと

**想定される実装上の課題:**
- 共有の `HttpClient` を使用する場合、並行リクエストで音声データが混ざる可能性がある
- speaker_id パラメータが正しく渡されない可能性がある

---

### 2. 同じ話者が連続して音声合成をリクエストした場合_順序が保証される

**目的:** 同じ話者が連続して複数の音声合成をリクエストした場合、すべてのリクエストが正しく処理されることを確認します。

**シナリオ:**
- 同じ話者（speaker_id=1）が3つのテキストを連続してリクエスト
- 各リクエストは30msの処理時間をシミュレート
- 各レスポンスには順序番号が含まれる

**検証内容:**
- 3つすべてのリクエストが処理されること
- すべてのレスポンスが空でないこと
- レスポンスに含まれる順序番号が1, 2, 3であること（順不同で受信される可能性があるため、ソートして検証）

**想定される実装上の課題:**
- 並行実行時にリクエストが失われる可能性がある
- レスポンスの順序が保証されない可能性がある

---

### 3. 2人の話者が交互に音声合成を行う場合_それぞれの音声が正しく分離される

**目的:** ラジオモードの典型的なシナリオとして、2人の話者が交互に発言する場合、それぞれの音声が正しく分離されることを確認します。

**シナリオ:**
- 話者A（speaker_id=10）と話者B（speaker_id=20）が交互に発言
- 合計4つのリクエスト（A→B→A→B）を並行して送信
- 各リクエストは40msの処理時間をシミュレート

**検証内容:**
- 4つすべてのリクエストが処理されること
- 話者Aの音声データ（2つ）が同じ識別子を持つこと
- 話者Bの音声データ（2つ）が同じ識別子を持つこと
- 話者AとBの音声データが異なること

**想定される実装上の課題:**
- speaker_id の混同による音声の取り違え
- リクエストのタイミングによる音声データの混在

---

### 4. ストリーミング音声合成で複数の話者が同時にリクエストした場合_それぞれのストリームが混ざらない

**目的:** ストリーミングAPIを使用する場合でも、複数の話者の音声ストリームが混ざらないことを確認します。

**シナリオ:**
- 話者1（speaker_id=1）と話者2（speaker_id=2）が同時にストリーミング音声合成をリクエスト
- 各話者のストリームは2つのチャンクで構成
- 各チャンクは30msの処理時間をシミュレート

**検証内容:**
- 両方の話者のストリームが空でないこと
- 話者1のすべてのチャンクが識別子 0x01 を含むこと
- 話者2のすべてのチャンクが識別子 0x02 を含むこと

**想定される実装上の課題:**
- `IAsyncEnumerable` の並行処理でストリームが混在する可能性
- チャンク単位での音声データの取り違え

---

### 5. 高負荷状態で5人の話者が同時に音声合成をリクエストした場合_すべての音声が正しく処理される

**目的:** 高負荷状態（5人の話者が同時にリクエスト）でも、すべての音声が正しく処理されることを確認します。

**シナリオ:**
- 5人の話者（speaker_id=1～5）がそれぞれ2回ずつリクエスト（合計10リクエスト）
- 各リクエストは20msの処理時間をシミュレート
- すべてのリクエストを並行して送信

**検証内容:**
- 10個すべてのリクエストが処理されること
- 各話者が正確に2回ずつリクエストを送信したこと
- 各レスポンスに正しい話者IDが含まれていること
- 各話者のレスポンスが正確に2つずつ返されること

**想定される実装上の課題:**
- 高負荷時のリクエスト失敗
- リソース競合による音声データの破損
- speaker_id の混同

---

### 6. ラジオモードシナリオ_2人のパーソナリティが交互に会話する場合_音声が正しく分離される

**目的:** 実際のラジオモードのユースケースに近いシナリオで、2人のパーソナリティが長い会話を行う場合でも音声が正しく分離されることを確認します。

**シナリオ:**
- 話者1（speaker_id=1）と話者2（speaker_id=2）が交互に8回発言
- 各発言は実際の会話文を使用
- 各リクエストは25msの処理時間をシミュレート

**検証内容:**
- 8つすべてのリクエストが処理されること
- 話者1のレスポンス（4つ）がすべて識別子 0x01 を含むこと
- 話者2のレスポンス（4つ）がすべて識別子 0x02 を含むこと

**想定される実装上の課題:**
- 長時間の会話での音声データの混在
- リクエストの順序とレスポンスの順序の不一致
- 会話のコンテキストが失われる可能性

---

## 実装上の注意点

### 現在の実装における潜在的な問題

1. **共有 HttpClient の使用**
   - 現在の `StyleBertVits2Service` は単一の `HttpClient` インスタンスを共有しています
   - これにより、並行リクエストで speaker_id が混同される可能性があります

2. **speaker_id の管理**
   - speaker_id がリクエストごとに正しく設定されているか確認が必要です
   - URLパラメータとして正しく渡されているか検証が必要です

3. **レスポンスの識別**
   - 各リクエストのレスポンスが正しいリクエストに対応しているか確認する仕組みが必要です

### 推奨される改善策

1. **リクエスト単位での speaker_id の保証**
   - リクエストごとに speaker_id を確実に設定する仕組み
   - リクエスト-レスポンスのペアリングを保証する仕組み

2. **並行処理の制御**
   - 必要に応じて、話者ごとのリクエストキューを実装
   - 同時実行数の制限（オプション）

3. **ログとデバッグ**
   - 各リクエストに一意のIDを付与してトレース可能にする
   - speaker_id と音声データの対応関係をログに記録

---

## テストの実行方法

すべての並行処理テストを実行:
```bash
dotnet test --filter "FullyQualifiedName~StyleBertVits2ServiceConcurrencyTests"
```

特定のテストを実行:
```bash
dotnet test --filter "FullyQualifiedName~StyleBertVits2ServiceConcurrencyTests.複数の話者が同時に音声合成をリクエストした場合"
```

詳細なログを表示:
```bash
dotnet test --filter "FullyQualifiedName~StyleBertVits2ServiceConcurrencyTests" --logger "console;verbosity=detailed"
```

---

## まとめ

これらのテストは、ラジオモード実装時に重要な音声分離機能が正しく動作することを保証します。
すべてのテストが成功することで、以下が保証されます:

1. ✅ 複数のマスコットが同時に話しても音声が混ざらない
2. ✅ 各マスコットの音声データが正しく識別される
3. ✅ 高負荷状態でも安定して動作する
4. ✅ ストリーミング配信でも音声が混在しない
5. ✅ 実際のラジオモードのユースケースに対応できる

これらのテストを定期的に実行することで、リファクタリングや機能追加時にも
並行処理の正確性を維持できます。
